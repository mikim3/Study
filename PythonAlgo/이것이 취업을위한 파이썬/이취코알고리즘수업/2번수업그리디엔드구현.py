
#그리디 1번문제 점원이 500우너 100원 50원 10원 짜리 동전이 무한히 존재 할때 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수는?
# 단,  거스를 돈은 항상 10의 배수다
# 큰돈부터 거슬러주면 되지 않을까? 라고 생각했다.
n=1260
count =0 
# 큰단위 화페부터 확인하기
array= [500,100,50,10]
for coin in array:
    count += n // coin
    n %= coin
print(count)


# 나는 풀긴 했지만 정당성을 분석해보자
# 가장 큰 화폐부터 거스르는 이유는 뭘까 ?
# 동전중 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올수 없기 떄문 



# N이 1이 될 때까지 다음 두과정 중 하나를 반복한다 단 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.

# 1. N에서 1을 뺍니다.
# 2. N을 K로 나눕니다.
# 예로 N이 17 K가 4일때   1번 과정으로 N은 16이 되고 이후  2번 과정을 두번 하면 N은 1이 된다.
# N 이 1이 될 때까찌 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성 



# 찾아낸 규칙 1   N이 k로 나누어 떨어지면 그떄부터는 쭉 2번만 시행하는게 좋다.
n=25
k=3
count=0
#
while n!=1:  
    if n%k==0:  # 나누어 떨어지는 수가 되면   
        n=n/k
    else: 
        n=n-1
    count+=1
print(count)
# 위의 과정은 시간 복잡도가 높다
#### 모범담안
n=25
k=3

result=0

## 이렇게하면 log의 시간복잡도를 가짐     기존에 한번비교 한번 반복문 계산에서 한번에 계산으로 바뀜
while True:
    # n이 k로 나누어 떨어지는 수가 될 때까지 뺴기
    target = (n//k) * k   
    result += (n - target)      # n-target는 나누어 떨어지기 위해서  - 를 반복해야하는 횟수
    n = target  # 위에서 - 해야하는 만큼 반복 했으니 나누어 떨어지는 수로 바꿈 
    # N 이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    # K로 나누기
    result += 1
    n //= k
#마지막으로 남은 수에 대하여 1씩 빼기
result += (n -1)
print(result)
# 직관으로 찾아낸 방법은 나눌수 있을때는 최대한 나눈다
# 정당성 분석
# K가 2이상이기만 하면 K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.


# 곱하기 혹은 더하기   













