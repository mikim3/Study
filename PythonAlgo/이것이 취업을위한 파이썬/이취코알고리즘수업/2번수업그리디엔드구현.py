
#그리디 1번문제 점원이 500우너 100원 50원 10원 짜리 동전이 무한히 존재 할때 손님에게 거슬러 주어야 할 돈이 N원일 때 거슬러 주어야 할 동전의 최소 개수는?
# 단,  거스를 돈은 항상 10의 배수다
# 큰돈부터 거슬러주면 되지 않을까? 라고 생각했다.
n=1260
count =0 
# 큰단위 화페부터 확인하기
array= [500,100,50,10]
for coin in array:
    count += n // coin
    n %= coin
print(count)


# 나는 풀긴 했지만 정당성을 분석해보자
# 가장 큰 화폐부터 거스르는 이유는 뭘까 ?
# 동전중 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올수 없기 떄문 



# N이 1이 될 때까지 다음 두과정 중 하나를 반복한다 단 두번째 연산은 N이 K로 나누어 떨어질 때만 선택할 수 있다.

# 1. N에서 1을 뺍니다.
# 2. N을 K로 나눕니다.
# 예로 N이 17 K가 4일때   1번 과정으로 N은 16이 되고 이후  2번 과정을 두번 하면 N은 1이 된다.
# N 이 1이 될 때까찌 1번 혹은 2번의 과정을 수행해야하는 최소 횟수를 구하는 프로그램을 작성 



# 찾아낸 규칙 1   N이 k로 나누어 떨어지면 그떄부터는 쭉 2번만 시행하는게 좋다.
n=25
k=3
count=0
#
while n!=1:  
    if n%k==0:  # 나누어 떨어지는 수가 되면   
        n=n/k
    else: 
        n=n-1
    count+=1
print(count)
# 위의 과정은 시간 복잡도가 높다
#### 모범담안
n=25
k=3

result=0

## 이렇게하면 log의 시간복잡도를 가짐     기존에 한번비교 한번 반복문 계산에서 한번에 계산으로 바뀜
while True:
    # n이 k로 나누어 떨어지는 수가 될 때까지 뺴기
    target = (n//k) * k   
    result += (n - target)      # n-target는 나누어 떨어지기 위해서  - 를 반복해야하는 횟수
    n = target  # 위에서 - 해야하는 만큼 반복 했으니 나누어 떨어지는 수로 바꿈 
    # N 이 K보다 작을 때 (더 이상 나눌 수 없을 때) 반복문 탈출
    if n < k:
        break
    # K로 나누기
    result += 1
    n //= k
#마지막으로 남은 수에 대하여 1씩 빼기
result += (n -1)
print(result)
# 직관으로 찾아낸 방법은 나눌수 있을때는 최대한 나눈다
# 정당성 분석
# K가 2이상이기만 하면 K로 나누는 것이 1을 빼는 것보다 항상 빠르게 N을 줄일 수 있다.


# 곱하기 혹은 더하기문제
# 문제 : 각자리 0~9까지의 수만 0134532 이런식으로 입력할때 + X 만으로 가장 큰수가 나오도록 계산하도록 하여라

# 0과1은 더하고 나머지수는 곱하는게 핵심
# data = input()

# # 첫 번째 문자를 숫자로 변경하여 대입 
# result = int(data[0])   # 왜 첫번째는 대입한다는 생각을 왜 못 했을까

# for i in range(1,len(data)):
#     # 두 수 중에서 하나라도 ''
#     num = int(data[i])
#     if num <= 1 or result <=1:
#         result += num
#     else:
#         result *= num
        
# print(result)


# 모험가 길드 
# N명의 모험가가 있다.
# 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야 한다.
# 최대 몇 개의 모험가 그룹을 만들 수 있나?   N명의 호험가에 대한 정보가 주어졌을때 여행을 떠날수 있는 그룹 수의 최대값을 구하는 프로그램을 작성하여라

# 입출
# 첫 쨰줄에 모험가수 N주어짐
# 둘쨰 줄에 공포도 값을 N이하 자연수로 주어짐  공백으로 구분

# 내 풀이 : 핵심은 가장 낮은 공포도 모험가 먼저 보내야 한다.
print("모험가 길드 문제")
n=input()
data=list(map(int,input().split()))
data.sort()

result = 0  # 총 그룹의 수 
count = 0 # 현재 그룹 포함된 모험가 수

for i in data: # data 값 하나 씩 비교 
    count += 1 # 
    if count >= i:  # 카운트보다 data현재 값이 낮으면 
        result += 1  # 결과 즉 그룹을 하나 추가한다.
        count=0      #

print(result)
